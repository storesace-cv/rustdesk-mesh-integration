[
  {
    "query": "SELECT name FROM pg_timezone_names",
    "rolname": "authenticator",
    "calls": 85,
    "mean_time": 247.4186788,
    "min_time": 52.745056,
    "max_time": 961.064375,
    "total_time": 21030.587698,
    "rows_read": 101490,
    "cache_hit_rate": "0",
    "prop_total_time": 61.82152228164003,
    "index_advisor_result": null
  },
  {
    "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: a24eb159-2301-4a81-98af-41548270ed35\n-- date: 2025-11-30T19:15:01.710Z",
    "rolname": "postgres",
    "calls": 50,
    "mean_time": 96.02576976,
    "min_time": 67.911471,
    "max_time": 235.226046,
    "total_time": 4801.288488,
    "rows_read": 5650,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 14.113869165420494,
    "index_advisor_result": null
  },
  {
    "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
    "rolname": "authenticator",
    "calls": 85,
    "mean_time": 24.4274860470588,
    "min_time": 18.142908,
    "max_time": 82.054842,
    "total_time": 2076.336314,
    "rows_read": 85,
    "cache_hit_rate": "99.9174469226047260",
    "prop_total_time": 6.1035988886005565,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
    "rolname": "postgres",
    "calls": 50,
    "mean_time": 16.22706426,
    "min_time": 5.287767,
    "max_time": 58.480521,
    "total_time": 811.353213,
    "rows_read": 1943,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 2.3850541628244577,
    "index_advisor_result": null
  },
  {
    "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
    "rolname": "postgres",
    "calls": 46,
    "mean_time": 11.6706272391304,
    "min_time": 2.349338,
    "max_time": 48.909209,
    "total_time": 536.848853,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.5781210589168952,
    "index_advisor_result": null
  },
  {
    "query": "create or replace function realtime.apply_rls(wal jsonb, max_record_bytes int = 1024 * 1024)\n          returns setof realtime.wal_rls\n          language plpgsql\n          volatile\n      as $$\n      declare\n          -- Regclass of the table e.g. public.notes\n          entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n          -- I, U, D, T: insert, update ...\n          action realtime.action = (\n              case wal ->> 'action'\n                  when 'I' then 'INSERT'\n                  when 'U' then 'UPDATE'\n                  when 'D' then 'DELETE'\n                  else 'ERROR'\n              end\n          );\n\n          -- Is row level security enabled for the table\n          is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\n          subscriptions realtime.subscription[] = array_agg(subs)\n              from\n                  realtime.subscription subs\n              where\n                  subs.entity = entity_;\n\n          -- Subscription vars\n          roles regrole[] = array_agg(distinct us.claims_role)\n              from\n                  unnest(subscriptions) us;\n\n          working_role regrole;\n          claimed_role regrole;\n          claims jsonb;\n\n          subscription_id uuid;\n          subscription_has_access bool;\n          visible_to_subscription_ids uuid[] = '{}';\n\n          -- structured info for wal's columns\n          columns realtime.wal_column[];\n          -- previous identity values for update/delete\n          old_columns realtime.wal_column[];\n\n          error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n          -- Primary jsonb output for record\n          output jsonb;\n\n      begin\n          perform set_config('role', null, true);\n\n          columns =\n              array_agg(\n                  (\n                      x->>'name',\n                      x->>'type',\n                      x->>'typeoid',\n                      realtime.cast(\n                          (x->'value') #>> '{}',\n                          coalesce(\n                              (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                              (x->>'type')::regtype\n                          )\n                      ),\n                      (pks ->> 'name') is not null,\n                      true\n                  )::realtime.wal_column\n              )\n              from\n                  jsonb_array_elements(wal -> 'columns') x\n                  left join jsonb_array_elements(wal -> 'pk') pks\n                      on (x ->> 'name') = (pks ->> 'name');\n\n          old_columns =\n              array_agg(\n                  (\n                      x->>'name',\n                      x->>'type',\n                      x->>'typeoid',\n                      realtime.cast(\n                          (x->'value') #>> '{}',\n                          coalesce(\n                              (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                              (x->>'type')::regtype\n                          )\n                      ),\n                      (pks ->> 'name') is not null,\n                      true\n                  )::realtime.wal_column\n              )\n              from\n                  jsonb_array_elements(wal -> 'identity') x\n                  left join jsonb_array_elements(wal -> 'pk') pks\n                      on (x ->> 'name') = (pks ->> 'name');\n\n          for working_role in select * from unnest(roles) loop\n\n              -- Update `is_selectable` for columns and old_columns\n              columns =\n                  array_agg(\n                      (\n                          c.name,\n                          c.type_name,\n                          c.type_oid,\n                          c.value,\n                          c.is_pkey,\n                          pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                      )::realtime.wal_column\n                  )\n                  from\n                      unnest(columns) c;\n\n              old_columns =\n                      array_agg(\n                          (\n                              c.name,\n                              c.type_name,\n                              c.type_oid,\n                              c.value,\n                              c.is_pkey,\n                              pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                          )::realtime.wal_column\n                      )\n                      from\n                          unnest(old_columns) c;\n\n              if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n                  return next (\n                      jsonb_build_object(\n                          'schema', wal ->> 'schema',\n                          'table', wal ->> 'table',\n                          'type', action\n                      ),\n                      is_rls_enabled,\n                      -- subscriptions is already filtered by entity\n                      (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n                      array['Error 400: Bad Request, no primary key']\n                  )::realtime.wal_rls;\n\n              -- The claims role does not have SELECT permission to the primary key of entity\n              elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n                  return next (\n                      jsonb_build_object(\n                          'schema', wal ->> 'schema',\n                          'table', wal ->> 'table',\n                          'type', action\n                      ),\n                      is_rls_enabled,\n                      (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n                      array['Error 401: Unauthorized']\n                  )::realtime.wal_rls;\n\n              else\n                  output = jsonb_build_object(\n                      'schema', wal ->> 'schema',\n                      'table', wal ->> 'table',\n                      'type', action,\n                      'commit_timestamp', to_char(\n                          (wal ->> 'timestamp')::timestamptz,\n                          'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'\n                      ),\n                      'columns', (\n                          select\n                              jsonb_agg(\n                                  jsonb_build_object(\n                                      'name', pa.attname,\n                                      'type', pt.typname\n                                  )\n                                  order by pa.attnum asc\n                              )\n                          from\n                              pg_attribute pa\n                              join pg_type pt\n                                  on pa.atttypid = pt.oid\n                          where\n                              attrelid = entity_\n                              and attnum > 0\n                              and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n                      )\n                  )\n                  -- Add \"record\" key for insert and update\n                  || case\n                      when action in ('INSERT', 'UPDATE') then\n                          case\n                              when error_record_exceeds_max_size then\n                                  jsonb_build_object(\n                                      'record',\n                                      (\n                                          select jsonb_object_agg((c).name, (c).value)\n                                          from unnest(columns) c\n                                          where (c).is_selectable and (octet_length((c).value::text) <= 64)\n                                      )\n                                  )\n                              else\n                                  jsonb_build_object(\n                                      'record',\n                                      (select jsonb_object_agg((c).name, (c).value) from unnest(columns) c where (c).is_selectable)\n                                  )\n                          end\n                      else '{}'::jsonb\n                  end\n                  -- Add \"old_record\" key for update and delete\n                  || case\n                      when action in ('UPDATE', 'DELETE') then\n                          case\n                              when error_record_exceeds_max_size then\n                                  jsonb_build_object(\n                                      'old_record',\n                                      (\n                                          select jsonb_object_agg((c).name, (c).value)\n                                          from unnest(old_columns) c\n                                          where (c).is_selectable and (octet_length((c).value::text) <= 64)\n                                      )\n                                  )\n                              else\n                                  jsonb_build_object(\n                                      'old_record',\n                                      (select jsonb_object_agg((c).name, (c).value) from unnest(old_columns) c where (c).is_selectable)\n                                  )\n                          end\n                      else '{}'::jsonb\n                  end;\n\n                  -- Create the prepared statement\n                  if is_rls_enabled and action <> 'DELETE' then\n                      if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                          deallocate walrus_rls_stmt;\n                      end if;\n                      execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n                  end if;\n\n                  visible_to_subscription_ids = '{}';\n\n                  for subscription_id, claims in (\n                          select\n                              subs.subscription_id,\n                              subs.claims\n                          from\n                              unnest(subscriptions) subs\n                          where\n                              subs.entity = entity_\n                              and subs.claims_role = working_role\n                              and realtime.is_visible_through_filters(columns, subs.filters)\n                  ) loop\n\n                      if not is_rls_enabled or action = 'DELETE' then\n                          visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                      else\n                          -- Check if RLS allows the role to see the record\n                          perform\n                              set_config('role', working_role::text, true),\n                              set_config('request.jwt.claims', claims::text, true);\n\n                          execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                          if subscription_has_access then\n                              visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                          end if;\n                      end if;\n                  end loop;\n\n                  perform set_config('role', null, true);\n\n                  return next (\n                      output,\n                      is_rls_enabled,\n                      visible_to_subscription_ids,\n                      case\n                          when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                          else '{}'\n                      end\n                  )::realtime.wal_rls;\n\n              end if;\n          end loop;\n\n          perform set_config('role', null, true);\n      end;\n    $$",
    "rolname": "supabase_admin",
    "calls": 1,
    "mean_time": 535.452572,
    "min_time": 535.452572,
    "max_time": 535.452572,
    "total_time": 535.452572,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.5740165508454858,
    "index_advisor_result": null
  },
  {
    "query": "SELECT t.oid, t.typname, t.typsend, t.typreceive, t.typoutput, t.typinput,\n       coalesce(d.typelem, t.typelem), coalesce(r.rngsubtype, $1), ARRAY (\n  SELECT a.atttypid\n  FROM pg_attribute AS a\n  WHERE a.attrelid = t.typrelid AND a.attnum > $2 AND NOT a.attisdropped\n  ORDER BY a.attnum\n)\n\nFROM pg_type AS t\nLEFT JOIN pg_type AS d ON t.typbasetype = d.oid\nLEFT JOIN pg_range AS r ON r.rngtypid = t.oid OR r.rngmultitypid = t.oid OR (t.typbasetype <> $3 AND r.rngtypid = t.typbasetype)\nWHERE (t.typrelid = $4)\nAND (t.typelem = $5 OR NOT EXISTS (SELECT $6 FROM pg_catalog.pg_type s WHERE s.typrelid != $7 AND s.oid = t.typelem))",
    "rolname": "supabase_admin",
    "calls": 25,
    "mean_time": 18.99963348,
    "min_time": 4.338806,
    "max_time": 44.155024,
    "total_time": 474.990837,
    "rows_read": 5469,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.3962832154216458,
    "index_advisor_result": null
  },
  {
    "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
    "rolname": "authenticator",
    "calls": 85,
    "mean_time": 5.54512928235294,
    "min_time": 1.226449,
    "max_time": 76.98345,
    "total_time": 471.335989,
    "rows_read": 3071,
    "cache_hit_rate": "99.9107415498085641",
    "prop_total_time": 1.3855394230791476,
    "index_advisor_result": null
  },
  {
    "query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
    "rolname": "supabase_admin",
    "calls": 7,
    "mean_time": 58.813255,
    "min_time": 47.270163,
    "max_time": 66.811811,
    "total_time": 411.692785,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.2102122416430792,
    "index_advisor_result": null
  },
  {
    "query": "select setting from pg_config where name = $1",
    "rolname": "supabase_admin",
    "calls": 1051,
    "mean_time": 0.320746764034253,
    "min_time": 0.036152,
    "max_time": 2.691812,
    "total_time": 337.104849,
    "rows_read": 1051,
    "cache_hit_rate": "0",
    "prop_total_time": 0.990953521269608,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
    "rolname": "postgres",
    "calls": 16,
    "mean_time": 19.447042875,
    "min_time": 2.122862,
    "max_time": 136.152035,
    "total_time": 311.152686,
    "rows_read": 1232,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.9146645346658797,
    "index_advisor_result": null
  },
  {
    "query": "-- postgres-migrations disable-transaction\nCREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_name_bucket_level_unique on storage.objects (name COLLATE \"C\", bucket_id, level)",
    "rolname": "supabase_storage_admin",
    "calls": 1,
    "mean_time": 310.877965,
    "min_time": 310.877965,
    "max_time": 310.877965,
    "total_time": 310.877965,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.9138569647269593,
    "index_advisor_result": null
  },
  {
    "query": "create or replace function realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n            returns bool\n            language sql\n            immutable\n        as $$\n        /*\n        Should the record be visible (true) or filtered out (false) after *filters* are applied\n        */\n            select\n                -- Default to allowed when no filters present\n                coalesce(\n                    sum(\n                        realtime.check_equality_op(\n                            op:=f.op,\n                            type_:=coalesce(\n                                col.type_oid::regtype, -- null when wal2json version <= 2.4\n                                col.type_name::regtype\n                            ),\n                            -- cast jsonb to text\n                            val_1:=col.value #>> '{}',\n                            val_2:=f.value\n                        )::int\n                    ) = count(1),\n                    true\n                )\n            from\n                unnest(filters) f\n                join unnest(columns) col\n                    on f.column_name = col.name;\n        $$",
    "rolname": "supabase_admin",
    "calls": 1,
    "mean_time": 274.336336,
    "min_time": 274.336336,
    "max_time": 274.336336,
    "total_time": 274.336336,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.8064391805037558,
    "index_advisor_result": null
  },
  {
    "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
    "rolname": "postgres",
    "calls": 26,
    "mean_time": 10.0977546538462,
    "min_time": 0.894936,
    "max_time": 41.13656,
    "total_time": 262.541621,
    "rows_read": 74,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.7717674325407905,
    "index_advisor_result": null
  },
  {
    "query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
    "rolname": "authenticator",
    "calls": 85,
    "mean_time": 3.06960628235294,
    "min_time": 1.584486,
    "max_time": 35.163274,
    "total_time": 260.916534,
    "rows_read": 84,
    "cache_hit_rate": "99.8649864986498650",
    "prop_total_time": 0.7669903262790545,
    "index_advisor_result": null
  },
  {
    "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
    "rolname": "supabase_auth_admin",
    "calls": 38,
    "mean_time": 6.86186410526316,
    "min_time": 0.190577,
    "max_time": 32.623607,
    "total_time": 260.750836,
    "rows_read": 38,
    "cache_hit_rate": "99.9696140990580371",
    "prop_total_time": 0.7665032403855871,
    "index_advisor_result": null
  },
  {
    "query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg(jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname )) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on (a.attrelid = c.oid and a.attnum = any(i.indkey)) join pg_namespace n on c.relnamespace = n.oid where i.indisprimary group by i.indrelid ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $20, c.oid::int8, $21, c.conname, $22, c.confdeltype, $23, c.confupdtype, $24, nsa.nspname, $25, csa.relname, $26, sa.attname, $27, nta.nspname, $28, cta.relname, $29, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $30 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $31, (a.attrelid || $32 || a.attnum), $33, c.oid::int8, $34, nc.nspname, $35, c.relname, $36, a.attnum, $37, a.attname, $38, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $39 end, $40, case when t.typtype = $41 then case when bt.typelem <> $42::oid and bt.typlen = $43 then $44 when nbt.nspname = $45 then format_type(t.typbasetype, $46) else $47 end else case when t.typelem <> $48::oid and t.typlen = $49 then $50 when nt.nspname = $51 then format_type(a.atttypid, $52) else $53 end end, $54, case when t.typtype = $55 then case when nt.nspname <> $56 then concat(nt.nspname, $57, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $58, a.attidentity in ($59, $60), $61, case a.attidentity when $62 then $63 when $64 then $65 else $66 end, $67, a.attgenerated in ($68), $69, not (a.attnotnull or t.typtype = $70 and t.typnotnull), $71, ( b.relkind in ($72, $73) or (b.relkind in ($74, $75) and pg_column_is_updatable(b.id, a.attnum, $76)) ), $77, uniques.table_id is not null, $78, check_constraints.definition, $79, col_description(c.oid, a.attnum), $80, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $81::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $82 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$83] as ordinal_position from pg_catalog.pg_constraint where contype = $84 and cardinality(conkey) = $85 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$86] as ordinal_position, substring( pg_get_constraintdef(oid, $87), $88, length(pg_get_constraintdef(oid, $89)) - $90 ) as definition from pg_constraint where contype = $91 and cardinality(conkey) = $92 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $93 and not a.attisdropped group by a.attrelid ) select case b.relkind when $94 then jsonb_build_object( $95, b.relkind, $96, b.id, $97, b.schema, $98, b.name, $99, b.rls_enabled, $100, b.rls_forced, $101, ts.replica_identity, $102, ts.bytes, $103, ts.size, $104, ts.live_rows_estimate, $105, ts.dead_rows_estimate, $106, b.comment, $107, coalesce(pk.primary_keys, $108::jsonb), $109, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $110::jsonb ), $111, coalesce(c.columns, $112::jsonb) ) when $113 then jsonb_build_object( $114, b.relkind, $115, b.id, $116, b.schema, $117, b.name, $118, b.rls_enabled, $119, b.rls_forced, $120, ts.replica_identity, $121, ts.bytes, $122, ts.size, $123, ts.live_rows_estimate, $124, ts.dead_rows_estimate, $125, b.comment, $126, coalesce(pk.primary_keys, $127::jsonb), $128, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $129::jsonb ), $130, coalesce(c.columns, $131::jsonb) ) when $132 then jsonb_build_object( $133, b.relkind, $134, b.id, $135, b.schema, $136, b.name, $137, (pg_relation_is_updatable(b.id, $138) & $139) = $140, $141, b.comment, $142, coalesce(c.columns, $143::jsonb) ) when $144 then jsonb_build_object( $145, b.relkind, $146, b.id, $147, b.schema, $148, b.name, $149, $150, $151, b.comment, $152, coalesce(c.columns, $153::jsonb) ) when $154 then jsonb_build_object( $155, b.relkind, $156, b.id, $157, b.schema, $158, b.name, $159, b.comment, $160, b.foreign_server_name, $161, b.foreign_data_wrapper_name, $162, b.foreign_data_wrapper_handler, $163, coalesce(c.columns, $164::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join columns c on b.id = c.table_id",
    "rolname": "postgres",
    "calls": 30,
    "mean_time": 8.49787973333333,
    "min_time": 5.500567,
    "max_time": 30.743848,
    "total_time": 254.936392,
    "rows_read": 30,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.7494110989550588,
    "index_advisor_result": null
  },
  {
    "query": "with records as (\n  select\n    c.oid::int8 as \"id\",\n    case c.relkind\n      when $1 then pg_temp.pg_get_tabledef(\n        concat(nc.nspname),\n        concat(c.relname),\n        $2,\n        $3,\n        $4\n      )\n      when $5 then concat(\n        $6, concat(nc.nspname, $7, c.relname), $8,\n        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)\n      )\n      when $11 then concat(\n        $12, concat(nc.nspname, $13, c.relname), $14,\n        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)\n      )\n      when $17 then concat($18, nc.nspname, $19, c.relname, $20)\n      when $21 then pg_temp.pg_get_tabledef(\n        concat(nc.nspname),\n        concat(c.relname),\n        $22,\n        $23,\n        $24\n      )\n    end as \"sql\"\n  from\n    pg_namespace nc\n    join pg_class c on nc.oid = c.relnamespace\n  where\n    c.relkind in ($25, $26, $27, $28, $29)\n    and not pg_is_other_temp_schema(nc.oid)\n    and (\n      pg_has_role(c.relowner, $30)\n      or has_table_privilege(\n        c.oid,\n        $31\n      )\n      or has_any_column_privilege(c.oid, $32)\n    )\n    and nc.nspname IN ($33)\n  order by c.relname asc\n  limit $34\n  offset $35\n)\nselect\n  jsonb_build_object(\n    $36, coalesce(jsonb_agg(\n      jsonb_build_object(\n        $37, r.id,\n        $38, r.sql\n      )\n    ), $39::jsonb)\n  ) \"data\"\nfrom records r",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 202.651193,
    "min_time": 202.651193,
    "max_time": 202.651193,
    "total_time": 202.651193,
    "rows_read": 1,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.5957135113557412,
    "index_advisor_result": null
  },
  {
    "query": "with records as (\n  select\n    c.oid::int8 as \"id\",\n    case c.relkind\n      when $1 then pg_temp.pg_get_tabledef(\n        concat(nc.nspname),\n        concat(c.relname),\n        $2,\n        $3,\n        $4\n      )\n      when $5 then concat(\n        $6, concat(nc.nspname, $7, c.relname), $8,\n        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)\n      )\n      when $11 then concat(\n        $12, concat(nc.nspname, $13, c.relname), $14,\n        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)\n      )\n      when $17 then concat($18, nc.nspname, $19, c.relname, $20)\n      when $21 then pg_temp.pg_get_tabledef(\n        concat(nc.nspname),\n        concat(c.relname),\n        $22,\n        $23,\n        $24\n      )\n    end as \"sql\"\n  from\n    pg_namespace nc\n    join pg_class c on nc.oid = c.relnamespace\n  where\n    c.relkind in ($25, $26, $27, $28, $29)\n    and not pg_is_other_temp_schema(nc.oid)\n    and (\n      pg_has_role(c.relowner, $30)\n      or has_table_privilege(\n        c.oid,\n        $31\n      )\n      or has_any_column_privilege(c.oid, $32)\n    )\n    and nc.nspname IN ($33)\n  order by c.relname asc\n  limit $34\n  offset $35\n)\nselect\n  jsonb_build_object(\n    $36, coalesce(jsonb_agg(\n      jsonb_build_object(\n        $37, r.id,\n        $38, r.sql\n      )\n    ), $39::jsonb)\n  ) \"data\"\nfrom records r",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 198.545578,
    "min_time": 198.545578,
    "max_time": 198.545578,
    "total_time": 198.545578,
    "rows_read": 1,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.5836446441967662,
    "index_advisor_result": null
  },
  {
    "query": "with records as (\n  select\n    c.oid::int8 as \"id\",\n    case c.relkind\n      when $1 then pg_temp.pg_get_tabledef(\n        concat(nc.nspname),\n        concat(c.relname),\n        $2,\n        $3,\n        $4\n      )\n      when $5 then concat(\n        $6, concat(nc.nspname, $7, c.relname), $8,\n        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)\n      )\n      when $11 then concat(\n        $12, concat(nc.nspname, $13, c.relname), $14,\n        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)\n      )\n      when $17 then concat($18, nc.nspname, $19, c.relname, $20)\n      when $21 then pg_temp.pg_get_tabledef(\n        concat(nc.nspname),\n        concat(c.relname),\n        $22,\n        $23,\n        $24\n      )\n    end as \"sql\"\n  from\n    pg_namespace nc\n    join pg_class c on nc.oid = c.relnamespace\n  where\n    c.relkind in ($25, $26, $27, $28, $29)\n    and not pg_is_other_temp_schema(nc.oid)\n    and (\n      pg_has_role(c.relowner, $30)\n      or has_table_privilege(\n        c.oid,\n        $31\n      )\n      or has_any_column_privilege(c.oid, $32)\n    )\n    and nc.nspname IN ($33)\n  order by c.relname asc\n  limit $34\n  offset $35\n)\nselect\n  jsonb_build_object(\n    $36, coalesce(jsonb_agg(\n      jsonb_build_object(\n        $37, r.id,\n        $38, r.sql\n      )\n    ), $39::jsonb)\n  ) \"data\"\nfrom records r",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 194.529356,
    "min_time": 194.529356,
    "max_time": 194.529356,
    "total_time": 194.529356,
    "rows_read": 1,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.571838556729005,
    "index_advisor_result": null
  }
]
